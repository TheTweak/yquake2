//
//  ImGuiHud.cpp
//  ref_metal
//
//  Created by SOROKIN EVGENY on 15.03.2023.
//

#include <sstream>

#include "ImGuiHud.hpp"
#include "../utils/Constants.h"
#include "../MetalRenderer.hpp"

ImGuiHud::ImGuiHud() {
    int cursorWidth = SDL_CURSOR_W;
    int cursorHeight = SDL_CURSOR_H;
    Uint8 cursorMask[cursorWidth * cursorHeight];
    Uint8 cursorData[cursorWidth * cursorHeight];
    for (int i = 0; i < cursorWidth; i++) {
        for (int j = 0; j < cursorHeight; j++) {
            cursorMask[i * j] = 1;
            cursorData[i * j] = 0;
        }
    }

    sdlCursor = SDL_CreateCursor(cursorData, cursorMask, cursorWidth, cursorHeight, 0, 0);
    SDL_SetCursor(sdlCursor);
}

void ImGuiHud::createFontsTexture() {
    if (fontTexture != NULL) {
        return;
    }
    unsigned char* pixels;
    int width, height;
    ImGuiIO& io = ImGui::GetIO();
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
    auto *textureDescriptor = MTL::TextureDescriptor::texture2DDescriptor(PIXEL_FORMAT, width, height, false);
    textureDescriptor->setUsage(MTL::TextureUsageShaderRead);
    textureDescriptor->setStorageMode(MTL::StorageModeManaged);
    auto *texture = MetalRenderer::getInstance().getDevice()->newTexture(textureDescriptor);
    texture->replaceRegion(MTL::Region(0, 0, width, height), 0, pixels, width * 4);
    io.Fonts->SetTexID((void*)texture);
    fontTexture = texture;
}

void drawImGui() {
    int mouseX, mouseY;
    size_t buttonState = SDL_GetMouseState(&mouseX, &mouseY);
    bool leftButton = buttonState & SDL_BUTTON(1);
    bool rightButton = buttonState & SDL_BUTTON(3);
            
    std::ostringstream ss;
    ss << "sdl mouse pos: " << mouseX << " " << mouseY;
    if (leftButton) {
        ss << " left pressed ";
    }
    if (rightButton) {
        ss << " right pressed";
    }
    
    ImGui::SetNextWindowSize(ImVec2(600, 300));
    ImGui::Begin("Metal RTX");
    ss << "\nimgui mouse pos: " << ImGui::GetIO().MousePos.x << " " << ImGui::GetIO().MousePos.y;
    ImGui::Text("%s", ss.str().data());
    
    ImGui::End();

//    ImGui::ShowDemoWindow();
}

void ImGuiHud::render(MTL::RenderCommandEncoder *enc, vector_uint2 viewportSize) {
    createFontsTexture();
    
    int mouseX, mouseY;
    size_t buttonState = SDL_GetMouseState(&mouseX, &mouseY);
    bool leftButton = buttonState & SDL_BUTTON(1);
    bool rightButton = buttonState & SDL_BUTTON(3);
    
    ImGui::GetIO().AddMousePosEvent((float) mouseX, (float) mouseY);
    ImGui::GetIO().AddMouseButtonEvent(0, leftButton);
    ImGui::GetIO().AddMouseButtonEvent(1, rightButton);
    ImGui::GetIO().DisplaySize.x = viewportSize.x;
    ImGui::GetIO().DisplaySize.y = viewportSize.y;
            
    ImGui::NewFrame();

    drawImGui();
    
    ImGui::Render();
    ImDrawData *drawData = ImGui::GetDrawData();
    
    float L = drawData->DisplayPos.x;
    float R = drawData->DisplayPos.x + drawData->DisplaySize.x;
    float T = drawData->DisplayPos.y;
    float B = drawData->DisplayPos.y + drawData->DisplaySize.y;
    float N = 0.0;
    float F = 1.0;
    const float orthoProjection[4][4] =
    {
        { 2.0f/(R-L),   0.0f,           0.0f,   0.0f },
        { 0.0f,         2.0f/(T-B),     0.0f,   0.0f },
        { 0.0f,         0.0f,        1/(F-N),   0.0f },
        { (R+L)/(L-R),  (T+B)/(B-T), N/(F-N),   1.0f },
    };
    
    // Will project scissor/clipping rectangles into framebuffer space
    ImVec2 clip_off = drawData->DisplayPos;         // (0,0) unless using multi-viewports
    ImVec2 clip_scale = drawData->FramebufferScale; // (1,1) unless using retina display which are often (2,2)
    
    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
    int fb_width = (int)(drawData->DisplaySize.x * drawData->FramebufferScale.x);
    int fb_height = (int)(drawData->DisplaySize.y * drawData->FramebufferScale.y);
    if (fb_width <= 0 || fb_height <= 0 || drawData->CmdListsCount == 0) {
        return;
    }
    
    for (int i = 0; i < drawData->CmdListsCount; i++) {
        const ImDrawList* cmdList = drawData->CmdLists[i];
        
        auto mtlVertexBuffer = MetalRenderer::getInstance().getDevice()->newBuffer(cmdList->VtxBuffer.size() * sizeof(ImDrawVert), MTL::ResourceStorageModeShared);
        auto mtlIndexBuffer = MetalRenderer::getInstance().getDevice()->newBuffer(cmdList->IdxBuffer.size() * sizeof(ImDrawIdx), MTL::ResourceStorageModeShared);
        
        const ImDrawVert* vertexBuffer = cmdList->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
        const ImDrawIdx* idxBuffer = cmdList->IdxBuffer.Data;   // index buffer generated by Dear ImGui
        
        std::memcpy(mtlVertexBuffer->contents(), vertexBuffer, cmdList->VtxBuffer.size() * sizeof(ImDrawVert));
        std::memcpy(mtlIndexBuffer->contents(), idxBuffer, cmdList->IdxBuffer.size() * sizeof(ImDrawIdx));
        
        enc->setVertexBuffer(mtlVertexBuffer, 0, 0);
        enc->setVertexBytes(&orthoProjection, sizeof(orthoProjection), 1);
        
        for (int cmd_i = 0; cmd_i < cmdList->CmdBuffer.Size; cmd_i++) {
            const ImDrawCmd* pcmd = &cmdList->CmdBuffer[cmd_i];
            if (pcmd->UserCallback) {
                pcmd->UserCallback(cmdList, pcmd);
            } else {
                
                // Project scissor/clipping rectangles into framebuffer space
                ImVec2 clip_min((pcmd->ClipRect.x - clip_off.x) * clip_scale.x, (pcmd->ClipRect.y - clip_off.y) * clip_scale.y);
                ImVec2 clip_max((pcmd->ClipRect.z - clip_off.x) * clip_scale.x, (pcmd->ClipRect.w - clip_off.y) * clip_scale.y);

                // Clamp to viewport as setScissorRect() won't accept values that are off bounds
                if (clip_min.x < 0.0f) { clip_min.x = 0.0f; }
                if (clip_min.y < 0.0f) { clip_min.y = 0.0f; }
                if (clip_max.x > fb_width) { clip_max.x = (float)fb_width; }
                if (clip_max.y > fb_height) { clip_max.y = (float)fb_height; }
                if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y) {
                    continue;
                }
                
                MTL::ScissorRect scissorRect = MTL::ScissorRect();
                scissorRect.x = clip_min.x;
                scissorRect.y = clip_min.y;
                scissorRect.width = clip_max.x - clip_min.x;
                scissorRect.height = clip_max.y - clip_min.y;
                enc->setScissorRect(scissorRect);
                
                if (ImTextureID texId = pcmd->GetTexID()) {
                    enc->setFragmentTexture((MTL::Texture*) texId, 0);
                }
                
                enc->setVertexBufferOffset(pcmd->VtxOffset * sizeof(ImDrawVert), 0);
                enc->drawIndexedPrimitives(MTL::PrimitiveTypeTriangle, pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? MTL::IndexTypeUInt16 : MTL::IndexTypeUInt32, mtlIndexBuffer, pcmd->IdxOffset * sizeof(ImDrawIdx));
            }
        }
        mtlVertexBuffer->autorelease();
        mtlIndexBuffer->autorelease();
    }
}
