//
//  ImGuiHud.cpp
//  ref_metal
//
//  Created by SOROKIN EVGENY on 15.03.2023.
//

#include <sstream>

#include "ImGuiHud.hpp"
#include "../utils/Constants.h"
#include "../MetalRenderer.hpp"

ImGuiHud::ImGuiHud() {
    int cursorWidth = SDL_CURSOR_W;
    int cursorHeight = SDL_CURSOR_H;
    Uint8 cursorMask[cursorWidth * cursorHeight];
    Uint8 cursorData[cursorWidth * cursorHeight];
    for (int i = 0; i < cursorWidth; i++) {
        for (int j = 0; j < cursorHeight; j++) {
            cursorMask[i * j] = 1;
            cursorData[i * j] = 0;
        }
    }

    sdlCursor = SDL_CreateCursor(cursorData, cursorMask, cursorWidth, cursorHeight, 0, 0);
    SDL_SetCursor(sdlCursor);
}

void ImGuiHud::createFontsTexture() {
    if (fontTexture != NULL) {
        return;
    }
    unsigned char* pixels;
    int width, height;
    ImGuiIO& io = ImGui::GetIO();
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
    auto *textureDescriptor = MTL::TextureDescriptor::texture2DDescriptor(PIXEL_FORMAT, width, height, false);
    textureDescriptor->setUsage(MTL::TextureUsageShaderRead);
    textureDescriptor->setStorageMode(MTL::StorageModeManaged);
    auto *texture = MetalRenderer::getInstance().getDevice()->newTexture(textureDescriptor);
    texture->replaceRegion(MTL::Region(0, 0, width, height), 0, pixels, width * 4);
    io.Fonts->SetTexID((void*)texture);
    fontTexture = texture;
}

void drawImGui() {
    int mouseX, mouseY;
    size_t buttonState = SDL_GetMouseState(&mouseX, &mouseY);
    bool leftButton = buttonState & SDL_BUTTON(1);
    bool rightButton = buttonState & SDL_BUTTON(3);
            
    std::ostringstream ss;
    ss << "sdl mouse pos: " << mouseX << " " << mouseY;
    if (leftButton) {
        ss << " left pressed ";
    }
    if (rightButton) {
        ss << " right pressed";
    }
    
    ImGui::SetNextWindowSize(ImVec2(600, 300));
    ImGui::Begin("Metal RTX");
        
    ss << "\nimgui mouse pos: " << ImGui::GetIO().MousePos.x << " " << ImGui::GetIO().MousePos.y;
    ImGui::Text("%s", ss.str().data());
    
    if (ImGui::Button("OK")) {
    }
    if (ImGui::CollapsingHeader("Help")) {
        ImGui::Text("ABOUT THIS DEMO:");
        ImGui::BulletText("Sections below are demonstrating many aspects of the library.");
        ImGui::BulletText("The \"Examples\" menu above leads to more demo contents.");
        ImGui::BulletText("The \"Tools\" menu above gives access to: About Box, Style Editor,\n"
                          "and Metrics/Debugger (general purpose Dear ImGui debugging tool).");
        ImGui::Separator();

        ImGui::Text("PROGRAMMER GUIDE:");
        ImGui::BulletText("See the ShowDemoWindow() code in imgui_demo.cpp. <- you are here!");
        ImGui::BulletText("See comments in imgui.cpp.");
        ImGui::BulletText("See example applications in the examples/ folder.");
        ImGui::BulletText("Read the FAQ at http://www.dearimgui.org/faq/");
        ImGui::BulletText("Set 'io.ConfigFlags |= NavEnableKeyboard' for keyboard controls.");
        ImGui::BulletText("Set 'io.ConfigFlags |= NavEnableGamepad' for gamepad controls.");
        ImGui::Separator();
        ImGui::Text("USER GUIDE:");
    }
    
    ImGui::End();

//    ImGui::ShowDemoWindow();
}

void ImGuiHud::render(MTL::RenderCommandEncoder *enc, vector_uint2 viewportSize) {
    createFontsTexture();
    
    int mouseX, mouseY;
    size_t buttonState = SDL_GetMouseState(&mouseX, &mouseY);
    bool leftButton = buttonState & SDL_BUTTON(1);
    bool rightButton = buttonState & SDL_BUTTON(3);
    
    ImGui::GetIO().AddMousePosEvent((float) mouseX, (float) mouseY);
    ImGui::GetIO().AddMouseButtonEvent(0, leftButton);
    ImGui::GetIO().AddMouseButtonEvent(1, rightButton);
    ImGui::GetIO().DisplaySize.x = viewportSize.x;
    ImGui::GetIO().DisplaySize.y = viewportSize.y;
    ImGui::GetIO().FontGlobalScale = 2.5;
            
    ImGui::NewFrame();

    drawImGui();
    
    ImGui::Render();
    ImDrawData *drawData = ImGui::GetDrawData();
    
    for (int i = 0; i < drawData->CmdListsCount; i++) {
        const ImDrawList* cmdList = drawData->CmdLists[i];
        
        auto mtlVertexBuffer = MetalRenderer::getInstance().getDevice()->newBuffer(cmdList->VtxBuffer.size() * sizeof(ImDrawVert), MTL::ResourceStorageModeShared);
        auto mtlIndexBuffer = MetalRenderer::getInstance().getDevice()->newBuffer(cmdList->IdxBuffer.size() * sizeof(ImDrawIdx), MTL::ResourceStorageModeShared);
        
        const ImDrawVert* vertexBuffer = cmdList->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
        const ImDrawIdx* idxBuffer = cmdList->IdxBuffer.Data;   // index buffer generated by Dear ImGui
        
        std::memcpy(mtlVertexBuffer->contents(), vertexBuffer, cmdList->VtxBuffer.size() * sizeof(ImDrawVert));
        std::memcpy(mtlIndexBuffer->contents(), idxBuffer, cmdList->IdxBuffer.size() * sizeof(ImDrawIdx));
        
        enc->setVertexBuffer(mtlVertexBuffer, 0, 0);
        enc->setVertexBytes(&viewportSize, sizeof(viewportSize), 1);
        
        for (int cmd_i = 0; cmd_i < cmdList->CmdBuffer.Size; cmd_i++) {
            const ImDrawCmd* pcmd = &cmdList->CmdBuffer[cmd_i];
            if (pcmd->UserCallback) {
                pcmd->UserCallback(cmdList, pcmd);
            } else {
                
                if (ImTextureID texId = pcmd->GetTexID()) {
                    enc->setFragmentTexture((MTL::Texture*) texId, 0);
                }
                
                enc->setVertexBufferOffset(pcmd->VtxOffset * sizeof(ImDrawVert), 0);
                enc->drawIndexedPrimitives(MTL::PrimitiveTypeTriangle, pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? MTL::IndexTypeUInt16 : MTL::IndexTypeUInt32, mtlIndexBuffer, pcmd->IdxOffset * sizeof(ImDrawIdx));
            }
        }
        mtlVertexBuffer->autorelease();
        mtlIndexBuffer->autorelease();
    }
}
